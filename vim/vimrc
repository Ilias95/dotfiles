""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Maintainer:
"       Ilias Stamatis <stamatis.iliass@gmail.com>
"
" Initially based on:
"       https://github.com/spf13/spf13-vim
"       https://bitbucket.org/pmav99/dotfiles/src/fdd48164c029/vim/vimrc
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Setup Environment {
    " The following two lines are required by Vundle.
    set nocompatible                " be iMproved (must be first line)
    filetype off                    " required!

    " Setup Vundle.
    set rtp+=~/.vim/bundle/vundle
    call vundle#rc()
" }

" Bundles {
    " Dependencies {
        Bundle 'gmarik/vundle'
    " }

    " General {
        Bundle 'scrooloose/nerdtree'
        Bundle 'jistr/vim-nerdtree-tabs'
        Bundle 'spf13/vim-autoclose'
        Bundle 'mbbill/undotree'
    " }

    " General Programming {
        " Code completion.
        Bundle 'Shougo/neocomplcache'
        Bundle 'Shougo/neosnippet'
        Bundle 'honza/snipmate-snippets'

        Bundle 'scrooloose/nerdcommenter'
        if executable('ctags')
            Bundle 'majutsushi/tagbar'
        endif
    " }

    " Python {
        if has('python')
            Bundle 'klen/python-mode'
        endif

    " }
" }

" General {
    filetype plugin indent on       " automatically detect file types
    syntax on                       " syntax highlighting
    set synmaxcol=120               " don't try to highlight lines longer than 120 chars
    set mouse-=a                    " automatically disable mouse usage
    scriptencoding utf-8
    set encoding=utf-8
    set modelines=2
    set laststatus=2                " always show a status line
    set showmode                    " display the current mode
    set showcmd                     " show partial commands in status line and
    set visualbell
    set ttyfast
    set ruler                       " show the ruler
    set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%)
    set backspace=indent,eol,start  " backspace for dummies
    set history=1000                " store a ton of history (default is 20)
    set shell=$SHELL                " use user's default shell
    set fillchars=diff:⣿,vert:│
    set autowrite                   " autosave files
    set title

    colorscheme darkblue            " load colorscheme
    set background=dark
" }

" Basic Stuff {
    " With a map leader it's possible to do extra key combinations.
    let mapleader = ","
    let maplocalleader = '\\'

    " Swap ; and :.
    " Saves typing and eliminates :Q style typos due to lazy holding shift.
    nnoremap ; :

    " Fast saving.
    nnoremap <leader>w :w!<cr>

    " Move to the beginning of a line.
    nnoremap 0 ^

    " Use jk to exit normal mode.
    " <Esc> is inconvinient as it requires stretching to the top of the keyboard.
    inoremap jk <Esc>

    " Del key is too far...
    inoremap <leader>d <Del>

    " Use s (insert before) or S (insert after) to insert a single character.
    " Returns to normal mode automatically. It allows repetitions as well.
    function! RepeatChar(char, count)
        return repeat(a:char, a:count)
    endfunction
    nnoremap s :<C-U>exec "normal i".RepeatChar(nr2char(getchar()), v:count1)<CR>
    nnoremap S :<C-U>exec "normal a".RepeatChar(nr2char(getchar()), v:count1)<CR>

    " Map F1 (help) to esc.
    inoremap <F1> <ESC>
    nnoremap <F1> <ESC>
    vnoremap <F1> <ESC>

    " When vimrc is edited, reload it.
    autocmd! bufwritepost vimrc source ~/.dotfiles/vim/vimrc
" }

" Indentation, Tabs, Spaces {
    set tabstop=4                   " show tabs as 4 spaces
    set shiftwidth=4                " use indents of 4 spaces
    set shiftround                  " always round to multiple of 'shiftwidth'
    set softtabstop=4               " let backspace delete indent
    set expandtab                   " tabs are spaces, not tabs
    set smarttab
    set formatoptions=qrn1
    set autoindent                  " indent at the same level of the previous line
" }

" Whitespace {
    " Remove trailing whitespaces when saving.
    autocmd BufWritePre * :%s/\s\+$//e

    " Insert empty line above or below while staying in normal mode.
    nnoremap <leader>o :set paste<CR>m`o<Esc>``:set nopaste<CR>
    nnoremap <leader>O :set paste<CR>m`O<Esc>``:set nopaste<CR>
" }

" Line Numbers {
    set number                      " in case relative line numbers are not supported
    set relativenumber              " relative line numbers on

    " Switch between relative and absolute line number.
    function! g:ToggleNuMode()
        if(&relativenumber == 1)
            set number
        else
            set relativenumber
        endif
    endfunc

    nnoremap <leader>n :call g:ToggleNuMode()<CR>
" }

" Scrolling and Folding {
    set scrolloff=3                 " minimum lines to keep above and below cursor
    set foldenable                  " auto fold code

    nnoremap <space> za             " map space to toggle the current fold open/closed

    " Code folding options.
    nnoremap <leader>f0 :set foldlevel=0<CR>
    nnoremap <leader>f1 :set foldlevel=1<CR>
    nnoremap <leader>f2 :set foldlevel=2<CR>
    nnoremap <leader>f3 :set foldlevel=3<CR>
    nnoremap <leader>f4 :set foldlevel=4<CR>
    nnoremap <leader>f5 :set foldlevel=5<CR>
    nnoremap <leader>f6 :set foldlevel=6<CR>
    nnoremap <leader>f7 :set foldlevel=7<CR>
    nnoremap <leader>f8 :set foldlevel=8<CR>
    nnoremap <leader>f9 :set foldlevel=9<CR>
" }

" Wrap, Vertical Line {
    set nowrap                      " not wrap long lines
    set whichwrap=b,s,h,l,<,>,[,]   " backspace and cursor keys wrap to

    " Wrapped lines goes down/up to next row, rather than next line in file.
    nnoremap j gj
    nnoremap k gk

    " Show/hide vertical line.
    function! g:ToggleColorColumn()
        if(&colorcolumn == 0)
            set colorcolumn=80
        else
            set colorcolumn=0
        endif
    endfunc

    nnoremap <leader>l :call g:ToggleColorColumn()<CR>
" }

" Buffers, Windows, Tabs {
    set hidden                      " allow buffer switching without saving
    set winminheight=0              " windows can be 0 line high
    set splitbelow                  " when splitting put new window below of the current one
    set splitright                  " when splitting put new window to the right of the current one
    au VimResized * :wincmd =       " resize splits when the windows is resized.
    au FocusLost * : silent! wall   " save when losing focus

    " Redraw screen.
    nnoremap <leader>u :syntax sync fromstart<cr>:redraw!<cr>

    " Easier moving in windows.
    noremap <C-J> <C-W>j<C-W>_
    noremap <C-K> <C-W>k<C-W>_
    noremap <C-L> <C-W>l<C-W>_
    noremap <C-H> <C-W>h<C-W>_

    noremap <Leader>= <C-w>=        " adjust viewports to the same size

    " Useful mappings for managing tabs.
    noremap <leader>tn :tabnew<cr>
    noremap <leader>to :tabonly<cr>
    noremap <leader>tc :tabclose<cr>
    noremap <leader>tm :tabmove
    nnoremap > gt
    nnoremap < gT

    " Jump to the desired tab immediately.
    function! MoveToTab(tabposition)
        tabfirst
        for i in range(a:tabposition)
            tabnext
        endfor
    endfunction

    nnoremap <leader>t0 :call MoveToTab(0)<CR>
    nnoremap <leader>t1 :call MoveToTab(1)<CR>
    nnoremap <leader>t2 :call MoveToTab(2)<CR>
    nnoremap <leader>t3 :call MoveToTab(3)<CR>
    nnoremap <leader>t4 :call MoveToTab(4)<CR>
    nnoremap <leader>t5 :call MoveToTab(5)<CR>
    nnoremap <leader>t6 :call MoveToTab(6)<CR>
    nnoremap <leader>t7 :call MoveToTab(7)<CR>
    nnoremap <leader>t8 :call MoveToTab(8)<CR>
    nnoremap <leader>t9 :call MoveToTab(9)<CR>
" }

" TimeOuts {
    " Time out on key codes but not mappings.
    " Basically this makes terminal Vim work sanely.
    set notimeout
    set ttimeout
    set ttimeoutlen=10
" }

" Highlight and Searching {
    set incsearch                   " incremental search
    set hlsearch                    " highlight search terms
    set ignorecase                  " case insensitive search
    set smartcase                   " case sensitive when uc present

    " Use sane regexes.
    nnoremap / /\v
    vnoremap / /\v

    " Matching pairs.
    set showmatch                   " show matching symbols (parens etc)
    set matchtime=3                 " time to show matching paren
    set matchpairs+=(:)
    set matchpairs+=[:]
    set matchpairs+={:}
    set matchpairs+=<:>

    " Clear highlighted search.
    nnoremap <silent> <leader>/ :nohlsearch<cr>

    " Keep search matches in the middle of the window.
    nnoremap n nzzzv
" }

" Backup and Swap {
    " Backup {
        let directory = $HOME . "/.vim/backup/"
        execute "set backupdir=".directory
        set backup                  " enable backups

        " Create backup directory if it doesn't exists.
        if !isdirectory(directory)
            execute "!mkdir -p ".directory
        endif
    " }

    " Swap {
        set noswapfile              " turn swap off
    " }
" }

" Shell Commands Output {
    " Display output of shell commands in new window.
    " Only one window by command, if a window already exists for a command, it will be reused.
    " E.g. :Shell ls
    function! s:ExecuteInShell(command, bang)
        let _ = a:bang != '' ? s:_ : a:command == '' ? '' : join(map(split(a:command), 'expand(v:val)'))

        if (_ != '')
            let s:_ = _
            let bufnr = bufnr('%')
            let winnr = bufwinnr('^' . _ . '$')
            silent! execute  winnr < 0 ? 'belowright new ' . fnameescape(_) : winnr . 'wincmd w'
            setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile wrap number
            silent! :%d
            let message = 'Execute ' . _ . '...'
            call append(0, message)
            echo message
            silent! 2d | resize 1 | redraw
            silent! execute 'silent! %!'. _
            silent! execute 'resize ' . line('$')
            silent! execute 'syntax on'
            silent! execute 'autocmd BufUnload <buffer> execute bufwinnr(' . bufnr . ') . ''wincmd w'''
            silent! execute 'autocmd BufEnter <buffer> execute ''resize '' .  line(''$'')'
            silent! execute 'nnoremap <silent> <buffer> <CR> :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
            " Reexecute command with <localleader>r in a window opened by :Shell.
            silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
            " Go to the previous window with <localleader>g.
            silent! execute 'nnoremap <silent> <buffer> <LocalLeader>g :execute bufwinnr(' . bufnr . ') . ''wincmd w''<CR>'
            nnoremap <silent> <buffer> <C-W>_ :execute 'resize ' . line('$')<CR>
            silent! syntax on
        endif
    endfunction

    command! -complete=shellcmd -nargs=* -bang Shell call s:ExecuteInShell(<q-args>, '<bang>')
" }

" Compile and Run Code {
    autocmd FileType python nnoremap <leader>r :w<cr> :!clear; ./%<cr>
    autocmd FileType c nnoremap <leader>r :!clear; ./%:r<cr>
    autocmd FileType c nnoremap <leader>m :w<cr> :Shell clear; make<cr>

    " Make file executable and reload it.
    nnoremap <leader>x :!chmod +x %<cr> :e %<cr>
" }

" Languages {
    " Greek {
        " Use Greek letters in command mode.
        :set langmap=ΑA,ΒB,ΨC,ΔD,ΕE,ΦF,ΓG,ΗH,ΙI,ΞJ,ΚK,ΛL,ΜM,ΝN,ΟO,ΠP,QQ,ΡR,ΣS,ΤT,ΘU,ΩV,WW,ΧX,ΥY,ΖZ,αa,βb,ψc,δd,εe,φf,γg,ηh,ιi,ξj,κk,λl,μm,νn,οo,πp,qq,ρr,σs,τt,θu,ωv,ςw,χx,υy,ζz
    " }
" }

" Misc {
    " Clipboard {
        if has ('x') && has ('gui') " on Linux use + register for copy-paste
            set clipboard=unnamedplus
        elseif has ('gui')          " one mac and windows, use * register for copy-paste
            set clipboard=unnamed
        endif

        noremap <leader>y "+y
        noremap <leader>p :set paste<CR>"+p<CR>:set nopaste<CR>
        noremap <leader>P :set paste<CR>"+P<CR>:set nopaste<CR>
        vnoremap <leader>y "+ygv

        " Yank from the cursor to the end of the line, to be consistent with C and D.
        nnoremap Y y$
    " }

    " Make sure Vim returns to the same line when you reopen a file.
    augroup line_return
        au!
        au BufReadPost *
            \ if line("'\"") > 0 && line("'\"") <= line("$") |
            \     execute 'normal! g`"zvzz' |
            \ endif
    augroup END

    " For when you forget to sudo.. Really Write the file.
    cnoremap w!! w !sudo tee % >/dev/null
" }

" Plugins {
    " Ctags {
        set tags=./tags;/,~/.vimtags
    " }

    " neocomplcache {
        let g:acp_enableAtStartup = 0
        let g:neocomplcache_enable_at_startup = 1
        let g:neocomplcache_enable_camel_case_completion = 1
        let g:neocomplcache_enable_smart_case = 1
        let g:neocomplcache_enable_underbar_completion = 1
        let g:neocomplcache_enable_auto_delimiter = 1
        let g:neocomplcache_max_list = 15
        let g:neocomplcache_force_overwrite_completefunc = 1

        " SuperTab like snippets behavior.
        inoremap <silent><expr><TAB> neosnippet#expandable() ?
            \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
            \ "\<C-e>" : "\<TAB>")
        snoremap <TAB> <Right><Plug>(neosnippet_jump_or_expand)

        " Define dictionary.
        let g:neocomplcache_dictionary_filetype_lists = {
            \ 'default' : '',
            \ 'vimshell' : $HOME.'/.vimshell_hist',
            \ 'scheme' : $HOME.'/.gosh_completions'
            \ }

        " Define keyword.
        if !exists('g:neocomplcache_keyword_patterns')
            let g:neocomplcache_keyword_patterns = {}
        endif
        let g:neocomplcache_keyword_patterns._ = '\h\w*'

        " Plugin key-mappings.
        inoremap <C-k> <Plug>(neosnippet_expand_or_jump)
        snoremap <C-k> <Plug>(neosnippet_expand_or_jump)
        inoremap <expr><C-g> neocomplcache#undo_completion()
        inoremap <expr><C-l> neocomplcache#complete_common_string()
        inoremap <expr><CR> neocomplcache#complete_common_string()
        " <TAB>: completion.
        inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
        inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<TAB>"
        " <CR>: close popup
        " <s-CR>: close popup and save indent.
        inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup()"\<CR>" : "\<CR>"
        inoremap <expr><CR> pumvisible() ? neocomplcache#close_popup() : "\<CR>"
        " <C-h>, <BS>: close popup and delete backword char.
        inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
        inoremap <expr><C-y> neocomplcache#close_popup()

        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        " Enable heavy omni completion.
        if !exists('g:neocomplcache_omni_patterns')
            let g:neocomplcache_omni_patterns = {}
        endif
        let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
        let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
        let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
        " Use honza's snippets.
        let g:neosnippet#snippets_directory='~/.vim/bundle/snipmate-snippets/snippets'

        " For snippet_complete marker.
        if has('conceal')
            set conceallevel=2 concealcursor=i
        endif
    " }

    " NerdTree {
        noremap <C-e> :NERDTreeToggle<CR>:NERDTreeMirror<CR>
        noremap <leader>e :NERDTreeFind<CR>
        nnoremap <leader>nt :NERDTreeFind<CR>

        let NERDTreeShowBookmarks=1
        let NERDTreeIgnore=['\.pyc', '\~$', '\.swo$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr']
        let NERDTreeChDirMode=0
        let NERDTreeQuitOnOpen=1
        let NERDTreeMouseMode=2
        let NERDTreeShowHidden=1
        let NERDTreeKeepTreeInNewTab=1
        let g:nerdtree_tabs_open_on_gui_startup=0
    " }

    " TagBar {
         nnoremap <silent> <leader>tt :TagbarToggle<CR>
    " }

    " python-mode {
        " Disable if python support not present.
        if has('python')
            " Disable pymode's custom syntax highlighting.
            let g:pymode_syntax = 0
            " Disable all python highlightings.
            let g:pymode_syntax_all = 0

            " Disable pylint checking every save.
            let g:pymode_lint_write = 0
            " Do not load run code plugin.
            let g:pymode_run = 0
            " Disable python folding.
            let g:pymode_folding = 0

            " Switch pylint, pyflakes, pep8, mccabe code-checkers.
            " Can have multiply values "pep8,pyflakes,mcccabe".
            let g:pymode_lint_checker = "pyflakes,mccabe"
        endif
    " }

    " undotree {
        " If undotree is opened, it is likely one wants to interact with it.
        let g:undotree_setfocuswhentoggle=1
        nnoremap <leader>u :undotreetoggle<cr>
    " }

    " misc {
        let g:nerdshutup=1
        let b:match_ignorecase = 1
    " }
" }
