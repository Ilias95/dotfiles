""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Maintainer:
"       Ilias Stamatis <stamatis.iliass@gmail.com>
"
" Sections:
"       -> Plugins
"       -> General
"       -> Clipboard
"       -> Indentation, Tabs, Spaces
"       -> Auto-closing
"       -> Whitespace
"       -> Line Number
"       -> Scrolling and Folding
"       -> Vertical Line
"       -> Code Navigation
"       -> Buffers, Windows, Tabs
"       -> Highlight and Searching
"       -> Backup and Swap
"       -> Compile and Run Code
"       -> Code snippets
"       -> Languages
"       -> Shell Command
"       -> Misc
"       -> Plugins Configuration
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Plugins {
    " The following 4 lines are required by the Vundle plugin manager
    set nocompatible                " be iMproved (must be first line)
    filetype off
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

    " Let Vundle manage Vundle, required
    Plugin 'VundleVim/Vundle.vim'

    " Vim motions. This plugin is really awesome!
    " Usage: for example type <leader><leader>w and navigate quickly
    Plugin 'easymotion/vim-easymotion'

    " Toggle code comments on/off
    Plugin 'preservim/nerdcommenter'

    if v:version >= 703 && has('lua')
        " Code completion
        Plugin 'Shougo/neocomplete.vim'
    endif

    if executable('ctags')
        " Navigation via file tags
        " Usage: Open the side bar with <leader>tt (custom map)
        Plugin 'majutsushi/tagbar'
    endif

    " The molokai theme
    Plugin 'tomasr/molokai'

    call vundle#end()               " required
    filetype plugin indent on       " required, automatically detect file types
" }

" General {
    set title                       " set window title
    set encoding=utf-8

    if has('statusline')
        set laststatus=2            " always show a status line
    endif

    if has('cmdline_info')
        set ruler                   " show the ruler
        set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%)
    endif

    set backspace=2                 " backspace as it needs to be

    " Time out on key codes but not mappings.
    set notimeout
    set ttimeout
    set ttimeoutlen=10

    syntax on                       " enable syntax highlighting
    colorscheme molokai

    let loaded_matchparen = 1       " don't do paren matching

    " With a map leader it's possible to do extra key combinations.
    let mapleader = ","

    " Save typing and eliminate :Q style typos due to lazy holding shift.
    nnoremap ; :

    " Quick save.
    nnoremap <leader>w :w!<cr>

    " Wrapped lines goes down/up to next row, rather than next line in file.
    noremap j gj
    noremap k gk
    noremap $ g$

    " Revert the functionality of ^ and 0
    noremap 0 g^
    noremap ^ g0

    " <Esc> is inconvinient as it requires stretching to the top of the keyboard.
    inoremap jk <Esc>

    " <Del> key is too far...
    inoremap <leader>d <Del>

    " Make sure Vim returns to the same line when you reopen a file.
    au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

    " For when you forget to sudo.. Really Write the file.
    cnoremap w!! w !sudo tee % >/dev/null
" }

" Clipboard {
    nnoremap <leader>p "+p
    nnoremap <leader>P "+P
    nnoremap <leader>y "+y
    vnoremap <leader>y "+ygv

    " Yank from the cursor to the end of the line
    nnoremap Y y$
" }

" Indentation, Tabs, Spaces {
    set tabstop=4                   " show tabs as 8 spaces
    set shiftwidth=4                " use indents of 8 spaces
    set shiftround                  " always round to multiple of 'shiftwidth'
    set softtabstop=4               " let backspace delete indent
    "set noexpandtab                 " tabs are tabs, not spaces
    set expandtab                   " tabs are spaces, not tabs
    set smarttab
    set formatoptions=qrn1
    set autoindent                  " indent at the same level of the previous line

    " all html files are html, no htmldjango etc.
    au BufNewFile,BufRead *.html set filetype=html

    function! g:ToggleIndentation(num)
        execute 'set tabstop='.a:num
        execute 'set shiftwidth='.a:num
        execute 'set softtabstop='.a:num
    endfunc

    " JOS is in C but I want to use real tabs instead of spaces
    " I leave this here as an example of how to add exceptions for specific projects or files
    "function! SetupEnvironment()
      "let l:path = expand('%:p')
      "if l:path =~ '/home/ilias/jos'
        "setlocal noexpandtab  " tabs are tabs, not spaces
      "endif
    "endfunction

    "autocmd! BufReadPost,BufNewFile * call SetupEnvironment()
" }

" Auto-closing {
    " I only care about auto-closing brackets of code blocks
    function! s:CloseBracket()
        if getline('.') =~# '^\s*\(struct\|class\|enum\) '
            return "{\<CR>};\<Esc>O"
        else
            return "{\<CR>}\<Esc>O"
        endif
    endfunction

    inoremap <expr> {<CR> <SID>CloseBracket()

    " This is also useful for languages like C
    inoremap (; ();<left><left>
" }

" Whitespace {
    " Remove trailing whitespace when saving.
    autocmd BufWritePre * :%s/\s\+$//e

    " But don't remove trailing whitespace when explicitly requested.
    nnoremap <leader>no :autocmd! BufWritePre<cr>

    " Clear a line quickly.
    nnoremap <leader><space> ^D

    " Insert empty line above or below while staying in normal mode.
    nnoremap <leader>o :set paste<cr>m`o<Esc>``:set nopaste<cr>
    nnoremap <leader>O :set paste<cr>m`O<Esc>``:set nopaste<cr>
" }

" Line Numbers {
    set number

    " Switch between relative and absolute line number.
    function! g:ToggleNuMode()
        if(&relativenumber == 1)
            set norelativenumber
        else
            set relativenumber
        endif
    endfunc

    nnoremap <leader>nn :call g:ToggleNuMode()<cr>
" }

" Scrolling and Folding {
    set foldenable                  " enable folding
    set scrolloff=3                 " minimum lines to keep above and below cursor

    " Map space to toggle the current fold open/closed.
    nnoremap <space> za

    nnoremap <leader>f0 :set foldlevel=0<cr>
    nnoremap <leader>f1 :set foldlevel=1<cr>
    nnoremap <leader>f2 :set foldlevel=2<cr>
    nnoremap <leader>f3 :set foldlevel=3<cr>
    nnoremap <leader>f4 :set foldlevel=4<cr>
    nnoremap <leader>f5 :set foldlevel=5<cr>
    nnoremap <leader>f6 :set foldlevel=6<cr>
    nnoremap <leader>f7 :set foldlevel=7<cr>
    nnoremap <leader>f8 :set foldlevel=8<cr>
    nnoremap <leader>f9 :set foldlevel=9<cr>
" }

" Vertical Line {
    if exists('+colorcolumn')
        " Automatically show the vertical line for files containing source code.
        autocmd FileType c,cpp,java,python,javascript set colorcolumn=80
    endif

    function! g:ToggleColorColumn()
        if(&colorcolumn == 0)
            set colorcolumn=80
        else
            set colorcolumn=0
        endif
    endfunc

    nnoremap <leader>l :call g:ToggleColorColumn()<cr>
" }

" Code Navigation {
    if has('cscope')
        " Look for a 'cscope.out' file starting from the current directory, going up to the root directory.
        let s:dirs = split(getcwd(), "/")
        while s:dirs != []
                let s:path = "/" . join(s:dirs, "/")
                if (filereadable(s:path . "/cscope.out"))
                        execute "cs add " . s:path . "/cscope.out " . s:path . " -v"
                        break
                endif
                let s:dirs = s:dirs[:-2]
        endwhile

        " Make CTRL-] search through cscope first, then ctags.
        set cscopetag

        " Hit 'CTRL-\' followed by one of the cscope search types below.
        " The result of the cscope search will be displayed in the current window.
        nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>
        nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
        nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>
        nmap <C-\>a :cs find a <C-R>=expand("<cword>")<CR><CR>
        nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>

        " Using 'CTRL-spacebar' then a search type makes the vim window split horizontally.
        " The search result will be displayed in the new window.
        nmap <C-@>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>
        nmap <C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>
        nmap <C-@>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>
        nmap <C-@>a :vert scs find a <C-R>=expand("<cfile>")<CR><CR>
        nmap <C-@>f :vert scs find f <C-R>=expand("<cfile>")<CR><CR>

        " The following is the most commonly used, so let's have an extra even easier mapping.
        nmap <C-@><C-@> :vert scs find g <C-R>=expand("<cword>")<CR><CR>
    endif
" }

" Buffers, Windows, Tabs {
    set hidden                      " allow buffer switching without saving
    set winminheight=0              " windows can be 0 lines high
    set splitbelow                  " when splitting put new window below of the current one
    set splitright                  " when splitting put new window to the right of the current one

    " Fast close window.
    nnoremap <leader>q :q<cr>
    nnoremap <leader><leader>q :q!<cr>

    " Easier moving in windows.
    nnoremap <C-J> <C-W>j
    nnoremap <C-K> <C-W>k
    nnoremap <C-L> <C-W>l
    nnoremap <C-H> <C-W>h

    " Make all windows (almost) equally high and wide.
    nnoremap <Leader>= <C-w>=

    " Useful mappings for managing tabs.
    nnoremap <leader>tn :tabnew<cr>
    nnoremap <leader>to :tabonly<cr>
    nnoremap <leader>tc :tabclose<cr>
    nnoremap <leader>tm :tabmove

    " Go to right/left tab.
    nnoremap > gt
    nnoremap < gT
" }

" Highlight and Searching {
    set incsearch                   " incremental search
    set hlsearch                    " highlight search terms
    set ignorecase                  " case insensitive search
    set smartcase                   " case sensitive when uc present

    " Use sane regexes.
    nnoremap / /\v
    vnoremap / /\v

    " Matching pairs.
    set matchtime=3                 " time to show matching paren
    set matchpairs+=(:)
    set matchpairs+=[:]
    set matchpairs+={:}
    set matchpairs+=<:>

    " Clear highlighted search.
    nnoremap <silent> <leader>/ :nohlsearch<cr>

    " Keep search matches in the middle of the window.
    nnoremap n nzzzv

    " Highlight word occurrences but do not jump to the next result.
    nnoremap <leader>* *N
" }

" Backup and Swap {
    " Backup {
        let directory = $HOME . "/.vim/backup/"

        " Create backup directory if it doesn't exists.
        if !isdirectory(directory)
            silent! execute "!mkdir -p ".directory
        endif

        set backup                  " enable backups
        execute "set backupdir=".directory
    " }

    " Swap {
        set noswapfile              " turn swap off
    " }
" }

" Compile and Run Code {
    " Run {
        autocmd FileType python,sh,bash,zsh nnoremap <leader>r :w<cr> :!clear; ./%<cr>
        autocmd FileType c,cpp nnoremap <leader>r :!clear; ./%:r<cr>
        autocmd FileType java nnoremap <leader>r :!clear; java %:r<cr>
    " }

    " Compile {
        autocmd FileType c,cpp,java nnoremap <leader>m :w<cr> :Shell clear; make<cr>
        autocmd FileType c nnoremap <leader>c8 :w<cr> :Shell gcc -O0 -Wall -W -pedantic -std=c89 -ggdb3 -o %:r %<cr>
        autocmd FileType c nnoremap <leader>c9 :w<cr> :Shell gcc -O0 -Wall -W -pedantic -ggdb3 -o %:r %<cr>
        autocmd FileType cpp nnoremap <leader>c9 :w<cr> :Shell g++ -O0 -Wall -W -pedantic -ggdb3 -o %:r %<cr>
        autocmd FileType java nnoremap <leader>c9 :w<cr> :Shell javac %<cr>
    " }

    " Make file executable and reload it.
    nnoremap <leader>x :!chmod +x %<cr> :e %<cr>
" }

" Code snippets {
    inoremap pr** printf("\n");<esc>4hi
    inoremap pri** printf("value: %d\n", );<left><left>

    inoremap main** #include <stdio.h><cr>#include <stdlib.h><cr><cr><cr>int main(void)<cr>{<cr>puts("hello");<cr>return 0;<cr>}<esc>kk
" }

" Languages {
    " Greek {
        set keymap=greek_utf-8
    " }

    " Easy change keymap.
    inoremap <leader>g <c-^>

    " Don't enable keymap by default in Insert mode and when entering a search pattern.
    set iminsert=0
    set imsearch=-1
" }

" Shell Command {
    " Display output of shell commands in new window.
    " Only one window by command, if a window already exists for a command, it will be reused.
    " E.g. :Shell ls
    function! s:ExecuteInShell(command, bang)
        let _ = a:bang != '' ? s:_ : a:command == '' ? '' : join(map(split(a:command), 'expand(v:val)'))

        if (_ != '')
            let s:_ = _
            let bufnr = bufnr('%')
            let winnr = bufwinnr('^' . _ . '$')
            silent! execute  winnr < 0 ? 'belowright new ' . fnameescape(_) : winnr . 'wincmd w'
            setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile wrap number
            silent! :%d
            let message = 'Execute ' . _ . '...'
            call append(0, message)
            echo message
            silent! 2d | resize 1 | redraw
            silent! execute 'silent! %!'. _
            silent! execute 'resize ' . line('$')
            silent! execute 'syntax on'
            silent! execute 'autocmd BufUnload <buffer> execute bufwinnr(' . bufnr . ') . ''wincmd w'''
            silent! execute 'autocmd BufEnter <buffer> execute ''resize '' .  line(''$'')'
            silent! execute 'nnoremap <silent> <buffer> <cr> :call <SID>ExecuteInShell(''' . _ . ''', '''')<cr>'
            " Reexecute command with <localleader>r in a window opened by :Shell.
            silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . _ . ''', '''')<cr>'
            " Go to the previous window with <localleader>g.
            silent! execute 'nnoremap <silent> <buffer> <LocalLeader>g :execute bufwinnr(' . bufnr . ') . ''wincmd w''<cr>'
            nnoremap <silent> <buffer> <C-W>_ :execute 'resize ' . line('$')<cr>
            silent! syntax on
        endif
    endfunction

    command! -complete=shellcmd -nargs=* -bang Shell call s:ExecuteInShell(<q-args>, '<bang>')
" }

" Misc {
    " quickly sign patches
    noremap <leader>ss iSigned-off-by: Ilias Stamatis <stamatis.iliass@gmail.com><esc>
" }

" Plugins Configuration {
    " neocomplete {
        " Use neocomplete.
        let g:neocomplete#enable_at_startup = 1
        " Use smartcase.
        let g:neocomplete#enable_smart_case = 1
        " Set minimum syntax keyword length.
        let g:neocomplete#sources#syntax#min_keyword_length = 3

        " <TAB>: completion.
        inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " }

    " nerdcommenter {
        " Add spaces after comment delimiters by default
        let g:NERDSpaceDelims = 1

        " Use // style comments for C since nesting /* */ comments isn't legal
        let g:NERDCustomDelimiters = { 'c': { 'left': '//','right': '' } }
    " }

    " TagBar {
        set tags=./tags;/,~/.vimtags
        nnoremap <silent> <leader>tt :TagbarToggle<cr>
    " }
" }
